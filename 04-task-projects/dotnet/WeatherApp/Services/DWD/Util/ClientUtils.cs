/*
 * Bright Sky
 *
 *  Bright Sky is a free and open-source weather API. It aims to provide an easy-to-use gateway to weather data that the [DWD](https://www.dwd.de/) – Germany's meteorological service – publishes on their [open data server](https://opendata.dwd.de/).  The public instance at `https://api.brightsky.dev/` is free-to-use for all purposes, **no API key required**! Please note that the [DWD's Terms of Use](https://www.dwd.de/EN/service/copyright/copyright_artikel.html) apply to all data you retrieve through the API.  > This documentation is generated from an OpenAPI specification. The current version is available from https://brightsky.dev/brightsky.yml.   ## Quickstart  * Check out [`/current_weather`](operations/getCurrentWeather) if you want to know what the weather's like _right now_. * Check out [`/weather`](operations/getWeather) for hourly weather observations and forecasts. * Check out [`/radar`](operations/getRadar) if you're looking for a high-resolution rain radar. * Check out [`/alerts`](operations/getAlerts) if you're interested in weather alerts.  ... or keep reading below for some background information.   ## Good to Know  * **Geographical coverage**: due to its nature as German meteorological service, the observations published by the DWD have a strong focus on Germany. The _forecasts_ cover the whole world, albeit at a much lower density outside of Germany. * **Historical coverage**: Bright Sky serves historical data going back to January 1st, 2010. If you need data that goes further back, check out our [infrastructure repository](https://github.com/jdemaeyer/brightsky-infrastructure) to easily set up your own instance of Bright Sky! * **Source IDs**: Bright Sky's _source IDs_ are a technical artifact and – unlike the [DWD station IDs](https://www.dwd.de/DE/leistungen/klimadatendeutschland/stationsliste.html) and [WMO station IDs](https://opendata.dwd.de/climate_environment/CDC/help/stations_list_CLIMAT_data.txt) – have no meaning in the real world. When making requests to Bright Sky, try to avoid them and supply lat/lon or station IDs instead.   ## Useful Links  * [Bright Sky source code and issue tracking](https://github.com/jdemaeyer/brightsky/) * [Bright Sky infrastructure configuration](https://github.com/jdemaeyer/brightsky-infrastructure/) * [DWD Open Data landing page](https://www.dwd.de/EN/ourservices/opendata/opendata.html) * [Additional explanation files for DWD Open Data](https://www.dwd.de/DE/leistungen/opendata/hilfe.html?nn=495490&lsbId=627548), including:     * [List of main observation stations](https://www.dwd.de/DE/leistungen/opendata/help/stationen/ha_messnetz.xls?__blob=publicationFile&v=1)     * [List of additional observation stations](https://www.dwd.de/DE/leistungen/opendata/help/stationen/na_messnetz.xlsx?__blob=publicationFile&v=10)     * [List of MOSMIX stations](https://www.dwd.de/DE/leistungen/met_verfahren_mosmix/mosmix_stationskatalog.cfg?view=nasPublication&nn=495490)     * [List of meteorological parameters](https://www.dwd.de/DE/leistungen/opendata/help/schluessel_datenformate/kml/mosmix_elemente_pdf.pdf?__blob=publicationFile&v=2) * [DWD Open Data FAQ (German)](https://www.dwd.de/DE/leistungen/opendata/faqs_opendata.html) * [DWD Copyright information](https://www.dwd.de/EN/service/copyright/copyright_artikel.html)   ## Data Sources  All data available through Bright Sky is taken or derived from data on the [DWD open data server](https://opendata.dwd.de/):  * **Current weather / SYNOP**:   * https://opendata.dwd.de/weather/weather_reports/synoptic/germany/json/ * **Hourly weather**:   * Historical: https://opendata.dwd.de/climate_environment/CDC/observations_germany/climate/   * Current day: https://opendata.dwd.de/weather/weather_reports/poi/   * Forecasts: https://opendata.dwd.de/weather/local_forecasts/mos/ * **Radar**:   * https://opendata.dwd.de/weather/radar/composite/rv/ * **Alerts**:   * https://opendata.dwd.de/weather/alerts/cap/COMMUNEUNION_DWD_STAT/ 
 *
 * The version of the OpenAPI document: 2.1.9
 * Contact: jakob@brightsky.dev
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System.Collections;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;

namespace Service.DWD.Util;
/// <summary>
/// Utility functions providing some benefit to API client consumers.
/// </summary>
public static class ClientUtils
{

    /// <summary>
    /// Identifier for ISO 8601 DateTime Format
    /// </summary>
    /// <remarks>See https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8 for more information.</remarks>
    // ReSharper disable once InconsistentNaming
    public static string ISO8601_DATETIME_FORMAT = "o";
    /// <summary>
    /// Sanitize filename by removing the path
    /// </summary>
    /// <param name="filename">Filename</param>
    /// <returns>Filename</returns>
    public static string SanitizeFilename(string filename)
    {
        Match match = Regex.Match(filename, @".*[/\\](.*)$");
        return match.Success ? match.Groups[1].Value : filename;
    }

    /// <summary>
    /// Convert params to key/value pairs.
    /// Use collectionFormat to properly format lists and collections.
    /// </summary>
    /// <param name="collectionFormat">The swagger-supported collection format, one of: csv, tsv, ssv, pipes, multi</param>
    /// <param name="name">Key name.</param>
    /// <param name="value">Value object.</param>
    /// <returns>A multimap of keys with 1..n associated values.</returns>
    public static Multimap<string, string> ParameterToMultiMap(string collectionFormat, string name, object value)
    {
        var parameters = new Multimap<string, string>();

        if (value is ICollection collection && collectionFormat == "multi")
        {
            foreach (var item in collection)
            {
                parameters.Add(name, ParameterToString(item));
            }
        }
        else if (value is IDictionary dictionary)
        {
            if (collectionFormat == "deepObject")
            {
                foreach (DictionaryEntry entry in dictionary)
                {
                    parameters.Add(name + "[" + entry.Key + "]", ParameterToString(entry.Value));
                }
            }
            else
            {
                foreach (DictionaryEntry entry in dictionary)
                {
                    parameters.Add(entry.Key.ToString(), ParameterToString(entry.Value));
                }
            }
        }
        else
        {
            parameters.Add(name, ParameterToString(value));
        }

        return parameters;
    }

    /// <summary>
    /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
    /// If parameter is a list, join the list with ",".
    /// Otherwise just return the string.
    /// </summary>
    /// <param name="obj">The parameter (header, path, query, form).</param>
    /// <param name="configuration">An optional configuration instance, providing formatting options used in processing.</param>
    /// <returns>Formatted string.</returns>
    public static string ParameterToString(object obj)
    {
        if (obj is DateTime dateTime)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            return dateTime.ToString(ISO8601_DATETIME_FORMAT);
        if (obj is DateTimeOffset dateTimeOffset)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            return dateTimeOffset.ToString(ISO8601_DATETIME_FORMAT);
        if (obj is bool boolean)
            return boolean ? "true" : "false";
        if (obj is ICollection collection)
            return string.Join(",", collection.Cast<object>());

        return Convert.ToString(obj, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Serializes the given object when not null. Otherwise return null.
    /// </summary>
    /// <param name="obj">The object to serialize.</param>
    /// <returns>Serialized string.</returns>
    public static string Serialize(object? obj)
    {
        return obj != null ? Newtonsoft.Json.JsonConvert.SerializeObject(obj) : null;
    }

    /// <summary>
    /// Encode string in base64 format.
    /// </summary>
    /// <param name="text">string to be encoded.</param>
    /// <returns>Encoded string.</returns>
    public static string Base64Encode(string text)
    {
        return Convert.ToBase64String(Encoding.UTF8.GetBytes(text));
    }

    /// <summary>
    /// Convert stream to byte array
    /// </summary>
    /// <param name="inputStream">Input stream to be converted</param>
    /// <returns>Byte array</returns>
    public static byte[] ReadAsBytes(Stream inputStream)
    {
        using (var ms = new MemoryStream())
        {
            inputStream.CopyTo(ms);
            return ms.ToArray();
        }
    }

    /// <summary>
    /// Select the Content-Type header's value from the given content-type array:
    /// if JSON type exists in the given array, use it;
    /// otherwise use the first one defined in 'consumes'
    /// </summary>
    /// <param name="contentTypes">The Content-Type array to select from.</param>
    /// <returns>The Content-Type header to use.</returns>
    public static string SelectHeaderContentType(string[] contentTypes)
    {
        if (contentTypes.Length == 0)
            return null;

        foreach (var contentType in contentTypes)
        {
            if (IsJsonMime(contentType))
                return contentType;
        }

        return contentTypes[0]; // use the first content type specified in 'consumes'
    }

    /// <summary>
    /// Select the Accept header's value from the given accepts array:
    /// if JSON exists in the given array, use it;
    /// otherwise use all of them (joining into a string)
    /// </summary>
    /// <param name="accepts">The accepts array to select from.</param>
    /// <returns>The Accept header to use.</returns>
    public static string SelectHeaderAccept(string[] accepts)
    {
        if (accepts.Length == 0)
            return null;

        if (accepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
            return "application/json";

        return string.Join(",", accepts);
    }

    /// <summary>
    /// Provides a case-insensitive check that a provided content type is a known JSON-like content type.
    /// </summary>
    public static readonly Regex JsonRegex = new Regex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$");

    /// <summary>
    /// Check if the given MIME is a JSON MIME.
    /// JSON MIME examples:
    ///    application/json
    ///    application/json; charset=UTF8
    ///    APPLICATION/JSON
    ///    application/vnd.company+json
    /// </summary>
    /// <param name="mime">MIME</param>
    /// <returns>Returns True if MIME type is json.</returns>
    public static bool IsJsonMime(string mime)
    {
        if (string.IsNullOrWhiteSpace(mime)) return false;

        return JsonRegex.IsMatch(mime) || mime.Equals("application/json-patch+json");
    }
}